<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Northwoods Events • Debug Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light dark; }
    body { font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
    h1 { margin: 0 0 6px; }
    .muted { color: #666; }
    .err { background: #fff3f3; border: 1px solid #e6b8b8; color: #a11; padding: 10px; border-radius: 6px; margin: 12px 0; }
    .badge { display:inline-block; padding:2px 6px; border:1px solid #ccc; border-radius:6px; font-size:12px; background:#f7f7f7; }
    .toolbar { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; margin: 12px 0 16px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 8px; vertical-align: top; }
    th { background: #f6f6f6; position: sticky; top: 0; z-index: 1; }
    a { word-break: break-all; }
  </style>
</head>
<body>
  <h1>Northwoods Events</h1>
  <div id="meta" class="muted">Loading…</div>
  <div id="errors" hidden class="err"></div>

  <div class="toolbar">
    <label>Source:
      <select id="sourceFilter">
        <option value="ALL">ALL SOURCES</option>
      </select>
    </label>
    <label>Search title:
      <input id="q" type="search" placeholder="filter by title…" />
    </label>
    <label><input type="checkbox" id="futureOnly" checked /> Future only</label>
    <span id="count" class="badge">0 events</span>
    <a id="rawLink" class="badge" href="#" target="_blank" rel="noopener">open report.json</a>
  </div>

  <table id="tbl">
    <thead>
      <tr>
        <th style="width: 180px;">Date</th>
        <th>Title</th>
        <th style="width: 260px;">Location</th>
        <th style="width: 360px;">URL</th>
        <th style="width: 210px;">Source</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    const $ = (id) => document.getElementById(id);
    const meta = $('meta');
    const errBox = $('errors');
    const sourceSel = $('sourceFilter');
    const q = $('q');
    const futureOnly = $('futureOnly');
    const countEl = $('count');
    const tbody = document.querySelector('#tbl tbody');
    const rawLink = $('rawLink');

    function addError(msg) {
      errBox.hidden = false;
      errBox.innerHTML += (errBox.innerHTML ? '<br>' : '') + msg;
      console.error(msg);
    }

    function candidateReportUrls() {
      const { origin, pathname } = window.location;
      const base = pathname.endsWith('/') ? pathname : pathname.replace(/\/[^/]*$/, '/');
      return [
        './report.json',
        base + 'report.json',
        origin + base + 'report.json',
      ];
    }

    function fmtDate(iso) {
      try {
        const d = new Date(iso);
        if (Number.isNaN(+d)) return iso || '';
        return d.toLocaleString(undefined, { dateStyle: 'medium', timeStyle: 'short' });
      } catch { return iso || ''; }
    }

    function normalizeEvents(report) {
      if (!report || typeof report !== 'object') return [];
      if (Array.isArray(report.events)) return report.events;

      if (report.events_by_source && typeof report.events_by_source === 'object') {
        const all = [];
        for (const [sid, arr] of Object.entries(report.events_by_source)) {
          if (!Array.isArray(arr)) continue;
          for (const ev of arr) {
            if (ev && typeof ev === 'object') {
              if (!ev.source_id) ev.source_id = sid;
              all.push(ev);
            }
          }
        }
        return all;
      }

      if (Array.isArray(report)) return report;
      if (Array.isArray(report.items)) return report.items;
      return [];
    }

    function getStart(ev) {
      // Added start_utc to support your current report.json
      return ev.start_utc || ev.start || ev.dtstart || ev.date || '';
    }

    function extractSources(evts) {
      const ids = new Set();
      for (const ev of evts) {
        ids.add(ev.source_id || ev.source || ev.calendar || '');
      }
      ids.delete('');
      return [...ids].sort();
    }

    function render(events) {
      const term = (q.value || '').toLowerCase();
      const sel = sourceSel.value;
      const today = new Date(); today.setHours(0,0,0,0);

      const filtered = events.filter(ev => {
        const title = (ev.title || '').toLowerCase();
        const sid = ev.source_id || ev.source || ev.calendar || '';
        if (sel !== 'ALL' && sid !== sel) return false;
        if (term && !title.includes(term)) return false;

        if (futureOnly.checked) {
          const s = getStart(ev);
          const d = new Date(s);
          if (!s || Number.isNaN(+d) || d < today) return false;
        }
        return true;
      }).sort((a, b) => {
        const ad = new Date(getStart(a) || 0);
        const bd = new Date(getStart(b) || 0);
        return ad - bd;
      });

      tbody.innerHTML = '';
      for (const ev of filtered) {
        const tr = document.createElement('tr');

        const tdDate = document.createElement('td');
        tdDate.textContent = fmtDate(getStart(ev));
        tr.appendChild(tdDate);

        const tdTitle = document.createElement('td');
        tdTitle.textContent = ev.title || '(no title)';
        tr.appendChild(tdTitle);

        const tdLoc = document.createElement('td');
        tdLoc.textContent = ev.location || '';
        tr.appendChild(tdLoc);

        const tdUrl = document.createElement('td');
        if (ev.url) {
          const a = document.createElement('a'); a.href = ev.url; a.textContent = ev.url; a.target = '_blank'; a.rel = 'noopener';
          tdUrl.appendChild(a);
        }
        tr.appendChild(tdUrl);

        const tdSrc = document.createElement('td');
        tdSrc.textContent = ev.source_id || ev.source || ev.calendar || '';
        tr.appendChild(tdSrc);

        tbody.appendChild(tr);
      }

      countEl.textContent = `${filtered.length} events`;
    }

    async function loadReport() {
      const candidates = candidateReportUrls();
      let lastError = null;
      for (const url of candidates) {
        try {
          const res = await fetch(url, { cache: 'no-store' });
          if (!res.ok) { lastError = `HTTP ${res.status} for ${url}`; continue; }
          const json = await res.json();

          const when = json.run_started_utc || json.generated_at || '';
          const srcs = json.sources_processed != null ? ` • sources: ${json.sources_processed}` : '';
          const total = json.total_events != null ? ` • events: ${json.total_events}` : '';
          meta.textContent = `Run started: ${when || '(unknown)'}${srcs}${total}`;

          rawLink.href = url;

          const events = normalizeEvents(json);
          if (!events.length) addError('report.json loaded but contains 0 normalized events');

          const ids = extractSources(events);
          for (const id of ids) {
            const opt = document.createElement('option');
            opt.value = id; opt.textContent = id;
            sourceSel.appendChild(opt);
          }
          render(events);

          sourceSel.onchange = () => render(events);
          q.oninput = () => render(events);
          futureOnly.onchange = () => render(events);
          return;
        } catch (e) {
          lastError = `Failed parsing ${url}: ${e.message || e}`;
        }
      }
      addError(lastError || 'report.json not found via any known path.');
      meta.textContent = 'Unable to load report.json – see error above.';
    }

    loadReport();
  </script>
</body>
</html>
